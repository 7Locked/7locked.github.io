<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Frisk's Sister â€” Battle Demo with Endings</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{--scale:2}
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family: monospace;display:flex;align-items:center;justify-content:center;}
  .wrap{display:grid;place-items:center;gap:10px}
  canvas { 
    width: 480px; /* visual size (canvas is 240x160 logical) */
    height: 320px;
    image-rendering: pixelated;
    background: #000;
    border: 4px solid #fff;
    display:block;
  }
  #menu { display:flex; gap:18px; justify-content:center; user-select:none; }
  .opt { padding:8px 12px; border:2px solid #fff; cursor:pointer; }
  .selected { background:#fff;color:#000; }
  #status { text-align:center; min-height:22px; }
  #cutscene { position: fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,0.95); color:#fff; }
  #cutscene .box{ border:3px solid #fff; padding:14px; width:640px; max-width:90%; text-align:center; background:#000; }
  #cutscene canvas{ width:320px; height:160px; image-rendering:pixelated; display:block; margin:0 auto 10px; border:2px solid #fff;}
  button { padding:8px 12px; border:2px solid #fff; background:#000;color:#fff; cursor:pointer; }
</style>
</head>
<body>
<div class="wrap">
  <canvas id="c" width="240" height="160"></canvas>

  <div id="menu" aria-hidden="false">
    <div class="opt selected" data-id="0">FIGHT</div>
    <div class="opt" data-id="1">ACT</div>
    <div class="opt" data-id="2">ITEM</div>
    <div class="opt" data-id="3">MERCY</div>
    <!-- TALK slot will be inserted dynamically when discovered -->
  </div>

  <div id="status">* A wild Training Dummy appeared!</div>
</div>

<!-- Cutscene overlay -->
<div id="cutscene">
  <div class="box" id="cutBox">
    <canvas id="cutCanvas" width="160" height="80"></canvas>
    <div id="cutText" style="white-space:pre-wrap; font-size:14px;"></div>
    <div style="margin-top:10px"><button id="playAgain">Play Again</button></div>
  </div>
</div>

<script>
(() => {
  // Canvas & ctx
  const c = document.getElementById('c');
  const ctx = c.getContext('2d');
  ctx.imageSmoothingEnabled = false;

  // State
  let enemy = { maxHp: 30, hp: 30 };
  let player = { x: 120, y: 140, size: 8, speed: 5, hp: 20, maxHp: 20 };
  let bullets = [];
  let turn = 'player'; // 'player' or 'enemy' or 'end'
  let menuIndex = 0;
  const menuEls = Array.from(document.querySelectorAll('.opt'));
  const menuDiv = document.getElementById('menu');
  const statusEl = document.getElementById('status');

  // Flags for endings
  let usedFight = false;
  let usedActCount = 0;
  let usedMercy = false;
  let usedTalk = false;
  let secretRevealed = false;

  // hidden TALK option insertion index (we'll append when revealed)
  let talkOptionEl = null;

  // utility: set status
  function setStatus(t){ statusEl.textContent = t; }

  // Draw functions (pixel style)
  function clear() {
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,c.width,c.height);
  }
  function drawText16(x,y,text){ ctx.fillStyle='#fff'; ctx.font='8px monospace'; ctx.fillText(text,x,y); }

  function drawBattle() {
    clear();
    // top HUD
    ctx.fillStyle = '#fff';
    ctx.fillRect(8,8,120,12);
    ctx.fillStyle = '#000';
    ctx.fillRect(10,10,116,8);
    ctx.fillStyle = '#fff';
    ctx.font = '8px monospace';
    ctx.fillText('DUMMY', 12, 17);
    // HP bar
    ctx.strokeStyle='#fff';
    ctx.strokeRect(140,8,80,10);
    ctx.fillStyle='#ff0';
    const w = Math.max(0, Math.floor((enemy.hp/enemy.maxHp)*76));
    ctx.fillRect(142,10,w,6);

    // battle box
    ctx.strokeStyle = '#fff'; ctx.strokeRect(40,40,160,90);

    // player soul as diamond (simple)
    ctx.fillStyle = '#f00';
    drawDiamond(player.x, player.y, player.size/2);

    // bullets (white squares)
    ctx.fillStyle = '#fff';
    bullets.forEach(b => ctx.fillRect(b.x|0, b.y|0, b.s, b.s));

    // bottom HUD -> show player HP small
    ctx.fillStyle='#fff';
    ctx.fillRect(10, 140, 60, 10);
    ctx.fillStyle='#000'; ctx.fillRect(12,142,56,6);
    ctx.fillStyle='#0f0';
    const pw = Math.max(0, Math.floor((player.hp/player.maxHp)*52));
    ctx.fillRect(12,142,pw,6);
    ctx.fillStyle='#fff'; ctx.fillText('YOU', 14, 148);
  }

  function drawDiamond(cx, cy, r){
    // diamond pixel engine: vertical strokes
    for(let dy=-r; dy<=r; dy++){
      const w = r - Math.abs(dy);
      ctx.fillRect(cx - w, cy + dy, w*2+1, 1);
    }
  }

  // Menu helpers
  function updateMenuVisual(){
    const opts = Array.from(menuDiv.querySelectorAll('.opt'));
    opts.forEach((el,i) => el.classList.toggle('selected', i === menuIndex));
  }

  function maybeRevealSecret(){
    if (secretRevealed) return;
    secretRevealed = true;
    // create TALK button visually but keep it hidden until player scrolls down past MERCY
    talkOptionEl = document.createElement('div');
    talkOptionEl.className = 'opt';
    talkOptionEl.dataset.id = '4';
    talkOptionEl.textContent = 'TALK';
    // keep it invisible but present. When 'revealed' we will add it to the menu in code flow.
    // We'll append but not select it until player scrolls down.
    menuDiv.appendChild(talkOptionEl);
    talkOptionEl.style.opacity = '0.2'; // show faintly once appended; becomes normal when revealed by scroll down
  }

  // handle keyboard input
  window.addEventListener('keydown', (e) => {
    if (turn === 'end') return;
    if (turn === 'player') {
      if (e.key === 'ArrowRight') { 
        menuIndex = (menuIndex + 1) % menuDiv.children.length; updateMenuVisual();
      } else if (e.key === 'ArrowLeft') {
        menuIndex = (menuIndex - 1 + menuDiv.children.length) % menuDiv.children.length; updateMenuVisual();
      } else if (e.key === 'Enter') {
        selectMenu(menuIndex);
      } else if (e.key === 'ArrowDown') {
        // special: if currently at MERCY (index of MERCY), pressing down will reveal talk (secret)
        const opts = Array.from(menuDiv.children).map(n => n.textContent);
        const mercyIndex = opts.indexOf('MERCY');
        if (menuIndex === mercyIndex) {
          // reveal TALK if not already
          if (!secretRevealed) maybeRevealSecret();
          // make talk fully visible and set it to be selectable next time
          if (talkOptionEl) talkOptionEl.style.opacity = '1';
          // move selection to TALK (if present)
          const newIndex = Array.from(menuDiv.children).findIndex(n => n.textContent === 'TALK');
          if (newIndex >= 0) { menuIndex = newIndex; updateMenuVisual(); setStatus('* A hidden option appears: TALK'); }
        }
      }
    } else if (turn === 'enemy') {
      // movement during enemy turn (continuous movement via keydown; key repeat will fire)
      if (e.key === 'ArrowLeft') player.x -= player.speed;
      if (e.key === 'ArrowRight') player.x += player.speed;
      if (e.key === 'ArrowUp') player.y -= player.speed;
      if (e.key === 'ArrowDown') player.y += player.speed;
      clampPlayerInBox();
    }
  });

  // clickable menu support
  menuDiv.addEventListener('click', (ev) => {
    const t = ev.target.closest('.opt');
    if (!t) return;
    const idx = Array.from(menuDiv.children).indexOf(t);
    menuIndex = idx;
    updateMenuVisual();
    if (turn === 'player') selectMenu(idx);
  });

  function clampPlayerInBox(){
    // battle box is at (40,40) size 160x90
    player.x = Math.max(40+6, Math.min(40+160-6, player.x));
    player.y = Math.max(40+6, Math.min(40+90-6, player.y));
  }

  // CORE: menu selection handler
  function selectMenu(idx){
    const option = menuDiv.children[idx]?.textContent || '??';
    if (turn !== 'player') return;
    if (option === 'FIGHT'){
      usedFight = true;
      const dmg = Math.floor(Math.random()*8)+6;
      enemy.hp = Math.max(0, enemy.hp - dmg);
      setStatus(`* You hit the enemy for ${dmg} damage! (HP: ${enemy.hp})`);
      if (enemy.hp <= 0) {
        // violence ending (enemy died by FIGHT)
        setTimeout(()=>showEnding('violence'), 700);
        turn = 'end';
        return;
      }
      // enemy retaliates
      setTimeout(()=>startEnemyTurn(), 600);
    }
    else if (option === 'ACT'){
      usedActCount++;
      setStatus(`* You act kindly. (Acts used: ${usedActCount})`);
      // small flavor: if actCount high, enemy calms (slightly reduce enemy aggression)
      if (usedActCount === 2) setStatus('* The enemy seems calmer...');
      setTimeout(()=>startEnemyTurn(), 700);
    }
    else if (option === 'ITEM'){
      player.hp = Math.min(player.maxHp, player.hp + 8);
      setStatus(`* You used a Monster Candy. HP: ${player.hp}/${player.maxHp}`);
      setTimeout(()=>startEnemyTurn(), 700);
    }
    else if (option === 'MERCY'){
      usedMercy = true;
      // if we've acted a few times (>=2) then mercy leads to True Pacifist, else Kindness Ending
      if (usedActCount >= 2) {
        setStatus('* You spare the enemy peacefully...');
        setTimeout(()=>showEnding('truepacifist'), 700);
      } else {
        setStatus('* You chose MERCY...');
        setTimeout(()=>showEnding('kindness'), 700);
      }
      turn = 'end';
      return;
    }
    else if (option === 'TALK'){
      // secret talk ending trigger
      usedTalk = true;
      setStatus('* You choose to TALK... something changes.');
      setTimeout(()=>showEnding('secret'), 800);
      turn = 'end';
      return;
    }
    updateMenuVisual();
  }

  // Enemy turn: spawn bullets and allow player to dodge for a few seconds
  let enemyTimer = 0;
  let enemyActive = false;
  function startEnemyTurn(){
    if (turn === 'end') return;
    turn = 'enemy';
    setStatus('* Enemy attacks! Dodge the patterns (use arrow keys).');
    bullets = [];
    // spawn bullets - quantity influenced by how many times player used Fight
    const count = 8 + (usedFight ? 3 : 0) - Math.min(4, usedActCount); // acting reduces bullets slightly
    for(let i=0;i<count;i++){
      bullets.push({
        x: 40 + 6 + Math.random() * (160 - 12),
        y: 30 - Math.random() * 80,
        s: 4 + Math.random()*3,
        vy: 0.6 + Math.random()*1.2,
        vx: (Math.random()-0.5) * 0.6
      });
    }
    enemyActive = true;
    enemyTimer = 0;
    // after 4 seconds, return to player turn if still alive
    setTimeout(()=>{ if (turn === 'enemy') { turn = 'player'; setStatus('* Your turn!'); bullets = []; enemyActive = false; } }, 4000);
  }

  // Endings & cutscenes
  const cutsceneOverlay = document.getElementById('cutscene');
  const cutCanvas = document.getElementById('cutCanvas');
  const cutCtx = cutCanvas.getContext('2d');
  cutCtx.imageSmoothingEnabled = false;
  const cutText = document.getElementById('cutText');
  const playAgainBtn = document.getElementById('playAgain');

  function showEnding(key){
    // key: 'violence', 'kindness', 'truepacifist', 'secret'
    cutsceneOverlay.style.display = 'flex';
    // fade-out/clear main canvas quickly
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,c.width,c.height);
    // choose cutscene content
    if (key === 'violence'){
      renderCutscenePixelArt('#330000', '#f00', 'You won.\nBut at what cost?', 'violence');
    } else if (key === 'kindness'){
      renderCutscenePixelArt('#001133', '#0f0', 'You showed mercy.\nA small warmth spreads.', 'kindness');
    } else if (key === 'truepacifist'){
      renderCutscenePixelArt('#0a2a0a', '#0ff', 'You spared with compassion.\nHope glimmers.', 'truepacifist');
    } else if (key === 'secret'){
      renderCutscenePixelArt('#111033', '#ffb', 'You chose TALK.\nShe remembers...\n\"You\'re family.\"', 'secret');
    }
  }

  function renderCutscenePixelArt(bg, spriteColor, text, which){
    // draw simple placeholder pixel sprite and background
    cutCtx.fillStyle = bg; cutCtx.fillRect(0,0,cutCanvas.width,cutCanvas.height);
    // draw simple "sister" sprite: block body + face
    const centerX = cutCanvas.width/2, centerY = cutCanvas.height/2 - 6;
    // small pixel sprite grid 8x8 scaled to 4
    const px = 4;
    // body
    cutCtx.fillStyle = spriteColor;
    for(let y=0;y<6;y++){
      for(let x=0;x<6;x++){
        cutCtx.fillRect(centerX - (3*px) + x*px, centerY - (3*px) + y*px, px-1, px-1);
      }
    }
    // eyes
    cutCtx.fillStyle = '#000';
    cutCtx.fillRect(centerX - px - 1, centerY - 2, 1, 1);
    cutCtx.fillRect(centerX + 1, centerY - 2, 1, 1);
    // face hint
    cutCtx.fillStyle = '#fff';
    cutCtx.fillRect(centerX - 2, centerY + 1, 4, 1);

    cutText.textContent = text;
  }

  playAgainBtn.addEventListener('click', () => {
    resetBattle();
    cutsceneOverlay.style.display = 'none';
    setStatus('* A wild Training Dummy appeared!');
  });

  // reset everything to initial state
  function resetBattle(){
    enemy.hp = enemy.maxHp;
    player.hp = player.maxHp;
    bullets = [];
    turn = 'player';
    menuIndex = 0;
    usedFight = false; usedActCount = 0; usedMercy = false; usedTalk = false; secretRevealed = false;
    // remove TALK if present
    if (talkOptionEl && menuDiv.contains(talkOptionEl)) { menuDiv.removeChild(talkOptionEl); talkOptionEl = null; }
    // reset menu visuals
    updateMenuVisual();
  }

  // Main loop
  let last = performance.now();
  function loop(now){
    const dt = now - last; last = now;
    // update bullets if enemy active
    if (turn === 'enemy' && enemyActive){
      bullets.forEach(b => { b.x += b.vx * (dt/16); b.y += b.vy * (dt/16); });
      // check collisions
      for(const b of bullets){
        if (b.x < player.x + player.size && b.x + b.s > player.x && b.y < player.y + player.size && b.y + b.s > player.y){
          // hit
          player.hp = Math.max(0, player.hp - 1);
          // move bullet offscreen to avoid spam
          b.y = 999;
          setStatus(`* Ouch! HP: ${player.hp}/${player.maxHp}`);
          if (player.hp <= 0){
            setTimeout(()=>showEnding('violence'), 500); // death treated like violence-ending flavor
            turn = 'end';
          }
        }
      }
    }

    // draw
    drawBattle();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // init visuals
  updateMenuVisual();
  setStatus('* Your turn! Use arrow keys to navigate menu.');

  // Small helper: clicking the menu text to pick
  menuDiv.addEventListener('mouseover', (ev) => {
    const el = ev.target.closest('.opt');
    if (!el) return;
    const idx = Array.from(menuDiv.children).indexOf(el);
    menuIndex = idx; updateMenuVisual();
  });

  // initial secret reveal hint: maybe reveal TALK option exists but faintly (not required)
  // maybeRevealSecret(); // we only reveal when player scrolls down on MERCY

})();
</script>
</body>
</html>
